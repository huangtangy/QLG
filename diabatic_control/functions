
import matplotlib.pyplot as plt
### qiskit simulator
#import itertools,h5py,scipy,jax,pickle
import numpy as np
from pathlib import Path
from scipy.linalg import norm,expm
from scipy.optimize import minimize
from itertools import product
from qutip.random_objects import rand_super_bcsz, rand_kraus_map, rand_unitary
import jax
from jax import numpy as jnp
from jax import jit, vmap, grad
from os import listdir
#import pandas as pd
import cvxpy as cp
from joblib import Parallel, delayed, parallel_backend
import scipy.io as sio
from qutip import qeye,fock,qeye,destroy,create,num,coherent,mesolve,Options,fidelity,Qobj,tensor,basis,identity,ket2dm,rand_ket
from numpy import exp
import cmath,scipy
from math import factorial,pi,sqrt
from scipy.special import laguerre,hyp1f1,genlaguerre,gammainc,gamma
from sympy import KroneckerDelta, I, exp
import matplotlib
import numpy as np
import matplotlib.pyplot as plt
from qutip import tensor,coherent, wigner
from qutip import displace

def get_fid(psi1,psi2):
    return np.abs(np.sum(psi1.conj().T@psi2))**2

def Nj(j,alpha):
    if j ==0 or j==2:
        nj = 8*np.exp(-alpha**2)*(np.cosh(alpha**2)+np.cos(alpha**2)*(-1)**(j/2))
    elif j ==1 or j==3:
        nj = 8*np.exp(-alpha**2)*(np.sinh(alpha**2)+np.sin(alpha**2)*(-1)**((j-1)/2))
    else:
        print('error')
    return nj

def rho_cat(Np,alpha):
    # producing four cat states
    alpa1,alpa2,alpa3,alpa4=coherent(Np,alpha),coherent(Np,-alpha),coherent(Np,1j*alpha),coherent(Np,-1j*alpha)
    psicatc0 = (1/np.sqrt(Nj(0,alpha)))*(alpa1+alpa2+alpa3+alpa4)
    psicatc1 = (1/np.sqrt(Nj(2,alpha)))*(alpa1+alpa2-alpa3-alpa4)
    psicate0= (1/np.sqrt(Nj(1,alpha)))*(alpa1-alpa2-1j*alpa3+1j*alpa4)
    psicate1 = (1/np.sqrt(Nj(3,alpha)))*(alpa1-alpa2+1j*alpa3-1j*alpa4)
    rhocatc0,rhocatc1,rhocate0,rhocate1 = ket2dm(psicatc0),ket2dm(psicatc1),ket2dm(psicate0),ket2dm(psicate1)
    return  [psicatc0,psicatc1,psicate0,psicate1],[rhocatc0 ,rhocatc1 ,rhocate0 ,rhocate1]

def plot_winger_2mod(psi,xvec = np.linspace(-5, 5, 200)):
    
    
    rho = ket2dm(psi)
    W0 = wigner(rho, xvec, xvec)

    coefficients = psi.full()  # 得到 numpy ndarray，形状为 (N, 1)
    coefficients = np.abs(coefficients)**2#.flatten()  # 转成一维数组
    # 可视化
    fig, axes = plt.subplots(1, 2,figsize=(4.7,2.1))
    c0 = axes[0].contourf(xvec, xvec, W0, 100, cmap='RdBu_r')
    axes[0].set_title(r'$|\psi\rangle$')
    axes[0].set_xlabel('x')
    axes[0].set_ylabel('p')
    plt.colorbar(c0, ax=axes[0])

    c1 = axes[1].plot(coefficients)
    axes[1].set_title('Fock PDF')
    axes[1].set_xlabel('Fock')
    axes[1].set_ylabel('Prob')
    plt.tight_layout()
    plt.show()
    return plt

def bionomial_state(Np):
    return [0.5*basis(Np,0)+((3/4)**0.5)*basis(Np,4),0.5*basis(Np,6)+((3/4)**0.5)*basis(Np,2)]#


#### The GKP states see ref: PRXQuantum.3.030301 we have the same parameters choosen in this paper
def finite_gkp_state(dim, sigma, mu, n_range):
    
    gkp = 0  # Initialize the GKP state
    delta = np.sqrt(np.pi) / 2  # Grid spacing factor
    
    for n1 in range(-n_range, n_range + 1):
        for n2 in range(-n_range, n_range + 1):
            # Calculate complex grid point alpha
            alpha = delta * ((2 * n1 + mu) + 1j * n2)
            # Gaussian envelope
            gaussian_weight = np.exp(-sigma**2 * abs(alpha)**2)
            # Phase term
            phase = np.exp(-1j * np.real(alpha) * np.imag(alpha))
            # Displaced vacuum state D(alpha) |0>
            displaced_state = displace(dim, alpha) * basis(dim, 0)

            # Add weighted and phased displaced state
            gkp += gaussian_weight * phase * displaced_state
    
    # Normalize the state
    return gkp.unit()




from qutip import displace,squeeze
def Cubic_phase_state(cubicity, xi,n_truncate):  
    # q real ,xi complex 
    a = destroy(n_truncate)
    gamm = cubicity 
    qubic_operator = (1j * gamm* (a + a.dag()) ** 3).expm()
    state =  qubic_operator * squeeze(n_truncate, xi) * fock(n_truncate, 0)
    return state



def fourleg_cat_state(n_truncate,alpha):  
    # q real ,xi complex 
    Np= n_truncate
    [psicatc0,psicatc1,psicate0,psicate1],[rhocatc0 ,rhocatc1 ,rhocate0 ,rhocate1] = rho_cat(Np,alpha)
    return  [psicatc0,psicatc1,psicate0,psicate1]


### useful functions 

def get_cnm(N,H):
    # get the cnm list from Hamiltonian H = sum_{n,m} c_{c,m} |n><m|
        Hnm = identity(N)*0.0
        cnm_list,indexlist = [],[]
        for n in range(N):
            for m in range(N):
                cnm = complex(H[n,m])
                if np.abs(cnm) >10**-8:
                    Hnm += cnm*basis(N,n)*basis(N,m).dag()
                    cnm_list.append([cnm,n,m])
                    indexlist.append([n,m])
        return cnm_list

def get_psi_fidelity(psi1,psi2):
    # return the fidelity between two states
    return np.abs(np.vdot(psi1,psi2))**2

